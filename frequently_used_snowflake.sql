--dedupe
CREATE OR REPLACE TABLE TABLE_WITH_DUPES AS
SELECT *
FROM TABLE_WITH_DUPES
QUALIFY 
    (ROW_NUMBER() OVER (PARTITION BY PHONE ORDER BY LANDLINE_PRIORITY_RANK, ID)) = 1            --THIS DEDUPES PHONE  BASED ON HIGHEST SCORE RANKING
    AND (ROW_NUMBER() OVER (PARTITION BY UNIQUE_ID ORDER BY LANDLINE_PRIORITY_RANK, ID)) = 1;   --THIS DEDUPES BY ZIP+ADDRESS (ONE PER ADDRESS)
--WE USE ID BECAUSE IT'S A UNIQUE IDENTIFIER, WITHOUT IT, WE GET DIFFERENT RESULTS EACH THIS IS RAN (IE ORDER BY AN IDENTITY COLUMN TO KEEP RESULTS CONSISTENT)
  
---this will list all of your column names in order if you need them for any part of the script:
SELECT LISTAGG(column_name, ',') WITHIN GROUP (ORDER BY ordinal_position) AS headers
FROM information_schema.columns
WHERE table_name = 'FILENAME_RAW'
  AND table_schema = 'PUBLIC'
  AND table_catalog = 'DATA_ENGINEERING';

--ALSO THIS
DESC TABLE PUBLIC.GPB2B_2025_3;

--ADD UNIQUE_ID
CREATE OR REPLACE TABLE FILENAME_new AS
SELECT *, ROW_NUMBER() OVER (ORDER BY FIRST, LAST) AS UNIQUE_ID---THE ORDER BY CLAUSE CAN BE ANYTHING IN THE TABLE, THIS DOES NOT GROUP/COUNT THEM, IT ONLY SORTS IT BY THOSE FIELDS
FROM FILENAME_RAW;

--ROWID
SELECT *, ROW_NUMBER() OVER (PARTITION BY column1, column2 ORDER BY column3, column4) AS rowid
FROM your_table;

--CHECK FOR DUPES
SELECT UNIQUE_ID,COUNT(*)
FROM FILENAME_new
GROUP BY UNIQUE_ID
HAVING COUNT(*)>1;
--0 NO UNIQUE_ID DUPES

--EXPORT STEP 1
COPY INTO @VIA.PRODUCTION.DATA_OUTBOX/exports/FILENAME_TM_FINAL.csv
FROM (
  SELECT *
  FROM "FILENAME_TM_FINAL"
)
HEADER = TRUE
SINGLE = TRUE
MAX_FILE_SIZE = 4900000000;

--SEARCH FOR TABLES
SELECT *
FROM information_schema.tables
WHERE TABLE_NAME LIKE '%FILENAME%';

--COMBINE ADDRESS1 AND ADDRESS2 INTO ADDRESS
UPDATE GPB2B_2025_3
SET ADDRESS = COALESCE(TRIM(ADDRESS1), '') || 
  CASE 
    WHEN (ADDRESS2 IS NOT NULL AND ADDRESS2 <> '') THEN ' ' || COALESCE(TRIM(ADDRESS2), '')
    ELSE ''
  END;

--2 TABLE UPDATE
UPDATE GPB2B_2025_3 AS A
SET A.SOHO = 'Y'
FROM VIA.PRODUCTION.CONSUMER_I834_20250716 AS B
WHERE TRIM(A.EMPCNT) = '21'
  AND TRIM(A.ZIP) = TRIM(B.ZIP)
  AND UPPER(TRIM(A.ADDRESS)) = UPPER(TRIM(B.ADDRESS));
--STRIG COMPARISONS IN SNOWLFAKE MUST BE EXACT - SO USE UPPER(TRIM(FIELDNAME)) ON BOTH SIDES

--UPDATE CASE WHEN
UPDATE GPB2B_2025_3_913_TEST_CONTACT_TITLES
SET ACTUAL_TITLE_GROUP = CASE TRIM(TITLE_GROUP)
    WHEN '1' THEN 'Owners' 
    WHEN '2' THEN 'Partners';
--EXAMPLE 2
UPDATE GPB2B_2025_3_913_TEST_FLASH_FINAL
SET
  COMPANY         = CASE WHEN COMPANY LIKE '%@%' THEN REPLACE(COMPANY, '@', '') ELSE COMPANY END,
  B2C_ADDRESS     = CASE WHEN B2C_ADDRESS LIKE '%@%' THEN REPLACE(B2C_ADDRESS, '@', '') ELSE B2C_ADDRESS END,
  MATCHKEY        = CASE WHEN MATCHKEY LIKE '%@%' THEN REPLACE(MATCHKEY, '@', '') ELSE MATCHKEY END
WHERE
  COMPANY LIKE '%@%' OR
  B2C_ADDRESS LIKE '%@%' OR  B2C_CITY LIKE '%@%' OR  B2C_STATE LIKE '%@%' OR
  MATCHKEY LIKE '%@%';


--REMOVE ANY ALPHA CHARS
update GPB2B_2025_3
set  SQ_FOOTAGE_ESTIMATED=''
WHERE REGEXP_LIKE(SQ_FOOTAGE_ESTIMATED, '[A-Za-z]'); --sets to SQ_FOOTAGE_ESTIMATED '' if any alpha chars found

--While you cannot create an index in snowflake, you can improve query performance by clustering the table on frequently filtered columns
ALTER TABLE "GPB2B_2025_3"
CLUSTER BY (
    "ZIP",
    "COMPANY",
    "ADDRESS",
    "PHONE",
    "SALECODE",
    "EMPCNT",
    "STATE",
    "SICCODE",
    "SICDESCRIPTION"
);

